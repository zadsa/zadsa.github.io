<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode刷题&amp;&amp;算法学习之旅</title>
      <link href="/2019/10/28/leetcode-shua-ti-xue-xi-zhi-lu/"/>
      <url>/2019/10/28/leetcode-shua-ti-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-算法和数据结构"><a href="#第一章-算法和数据结构" class="headerlink" title="第一章  算法和数据结构"></a>第一章  算法和数据结构</h2><p>衡量算法好坏评判标准：</p><ul><li>时间复杂度</li><li>空间复杂度</li></ul><h3 id="数据结构-data-structure"><a href="#数据结构-data-structure" class="headerlink" title="数据结构 data structure"></a>数据结构 data structure</h3><h4 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1. 线性结构"></a>1. 线性结构</h4><p>数据 链表 -&gt; 衍生出的栈、队列、哈希表</p><h4 id="2-树"><a href="#2-树" class="headerlink" title="2. 树"></a>2. 树</h4><p>二叉树、二叉堆</p><h4 id="3-图"><a href="#3-图" class="headerlink" title="3. 图"></a>3. 图</h4><h4 id="4-其他数据结构"><a href="#4-其他数据结构" class="headerlink" title="4. 其他数据结构"></a>4. 其他数据结构</h4><h3 id="时间复杂度-time-complexity"><a href="#时间复杂度-time-complexity" class="headerlink" title="时间复杂度 time complexity"></a>时间复杂度 time complexity</h3><p>定义：执行算法消耗的时间成本</p><p>$T(n)=O(f(n))$ </p><p>基本操作执行次数n</p><p>渐进时间复杂度：大O表示法 asymptotic time complexity</p><p>时间复杂度原则：</p><ul><li>常量1</li><li>只保留时间函数中的最高阶项</li><li>如果最高阶项存在，则省去最高阶项前面的系数</li><li>$O(1)$ $O(log^n)$ $O(n)$ $O(n^2)$ …</li></ul><p><strong>时间复杂度带来的巨大差异</strong></p><h3 id="空间复杂度-space-complexity"><a href="#空间复杂度-space-complexity" class="headerlink" title="空间复杂度 space complexity"></a>空间复杂度 space complexity</h3><p>定义：执行算法消耗的空间成本</p><p>$S(n)=O(f(n))$ $n$为问题的规模，$f(n)$为算法所占存储空间的函数</p><p>空间复杂度的计算</p><ul><li>常量空间  $O(1)$ </li><li>线性空间  $O(n)$ </li><li>二维空间 $O(n^2)$</li><li>递归空间：与递归深度成正比</li></ul><h2 id="第二章-数据结构基础"><a href="#第二章-数据结构基础" class="headerlink" title="第二章 数据结构基础"></a>第二章 数据结构基础</h2><h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h3><p>有限个相同类型的变量所组成的有序组合</p><p>顺序存储</p><p>数组的基本操作：增 删 改 查</p><ol><li>读取元素</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出数组中下标为3的元素</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>更新元素</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>插入元素：尾部插入 中间插入 超范围插入</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">MyArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>Array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表-Hash-Table"><a href="#哈希表-Hash-Table" class="headerlink" title="哈希表 Hash Table"></a>哈希表 Hash Table</h3><p><code>哈希表</code>是一种使用<code>哈希函数</code>组织数据，以支持<code>快速插入和搜索</code>的数据结构。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射</p><ul><li>哈希集合是<code>集合</code>数据结构的实现之一，用于存储<code>非重复值</code></li><li>哈希集合是<code>映射</code>数据结构的实现之一，用于存储<code>(key,value)</code>键值对</li></ul><h4 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h4><p>哈希表的关键思想是使用哈希函数<code>将键值Keys映射到存储桶Buckets</code>，更确切的说</p><ol><li>当我们插入一个新的Key时，哈希函数将决定该Key应该分配到哪个Bucket中，并将该Key存储在相应的Bucket中；</li><li>当我们想搜索一个Key时，哈希表将使用相同的哈希函数来查找对应的Bucket，并只在特定的Bucket中进行搜索</li></ol><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/09/06/screen-shot-2018-02-19-at-183537.png" alt="hashmap" style="zoom:30%;"><p>如上图所示，我们使用$y=x\pmod5$来完成插入和搜索：</p><ul><li>插入：我们通过哈希函数解析键，将他们映射到相应的Bucket中<ul><li>例如，1987mod5=2，即：1987分配给Bucket 2，而24分配给Bucket 4</li></ul></li><li>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索<ul><li>如果我们搜索1987，我们使用相同的哈希函数将1987映射到2，因此我们在Bucket 2搜索，在该桶中成功找到了1987</li><li>例如，如果我们搜索23，将23映射到3，并在Bucket 3中搜索，我们发现23不在Bucket 3中，这意味着23不在哈希表中</li></ul></li></ul><h4 id="设计哈希表的关键"><a href="#设计哈希表的关键" class="headerlink" title="设计哈希表的关键"></a>设计哈希表的关键</h4><p>在设计哈希表时，应注意两个基本因素：</p><p><strong>哈希函数</strong></p><hr><p>哈希函数的设计是一个开放的问题，其思想是尽可能将Key分配到Bucket中，理想情况下，完美的哈希函数是建立Key和Bucket之间的一一对应，然而，大多数情况，哈希函数并不完美，他需要在Bucket的数量和Bucket的容量之间进行权衡</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/05/04/screen-shot-2018-05-04-at-145454.png" alt="img"></p><p><strong>哈希冲突</strong></p><hr><p>理想情况下，如果我们的哈希函数是完美的一对一映射，那么我们将不需要处理冲突，比较操蛋的是，多数情况下，冲突几乎不可避免，例如，在上面我们使用的哈希函数$y=x\pmod5$中，1987和2都分配给了Bucket 2，这是一个冲突。</p><p>冲突解决算法应解决以下几个问题：</p><ol><li>如何组织同一个Bucket中的值？</li><li>如果为同一个Bucket分配了太多的Key，怎么处理？</li><li>如何在特定的Bucket中搜索目标值？</li></ol><p>根据我们的哈希函数，这些问题与<code>Bucket的容量</code>和可能映射到<code>同一个Bucket</code>的<code>Key的数目</code>有关</p><p>我们假设存储最大键数的Bucket有<code>N</code>个Key</p><p>通常，如果N为常数且很小，我们可以简单的使用数组将Key存储在同一个Bucket中，如果N是可变的或者很大，我们可能需要使用<code>高度平衡的二叉树</code>来代替</p><p><strong>特点：</strong></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>若关键字为k,则将其存放在f(k)的位置上，f为散射函数，按这个思想建立的表为散列表</li><li>对不同的关键字可能得到同一散列地址，即：$k1\neq k2$ ，而$f(k1)=f(k2)$，这种现象称为哈希冲突</li><li>若对于关键字集合中的任意一个关键字，经散射函数映象到地址集合中任何一个地址的概率是相等的，则称此类函数为均匀散列函数（Uniform Hash FUnction）这就是使关键字经过散射函数得到一个“随机的地址”，从而减少冲突</li></ul><h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p>产生冲突后去寻找下一个空闲的空间，函数定义为：<br>$$<br>hash_i=(hash(key)+d_i)mod\;m,\;i=1,2,\dots,k(k\le m-1)<br>$$<br>其中，$hash(key)$是哈希函数，$d_i$是增量序列，$i$为已冲突的次数</p><ul><li>线性探测法：$d_i=i$，或者其他线性函数，相当于逐个探测存放地址的表，直到查到一个空单元，然后放置在该单元</li><li>平方探测法：$d_i=\pm1^2,\pm2^2,\pm3^2,\dots,\pm k^2(k\leq m/2)$</li></ul><h5 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h5><p>散列到同一位置的元素，不是继续往下探测，而是在这个位置是一个链表，这些元素都存放在链表上</p><h5 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h5><p>如果一次不够，就再来一次，直到冲突不再发生为止</p><h5 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h5><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表（注意：在这个方法里面是把元素分开为两个表来存储）</p><h4 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h4><ul><li>查字典</li><li>网络防火墙中，根据源IP，目的IP，目的端口，协议号构成的五元组来标识一条网络数据流，并且根据五元组来建立会话表项（session entry）,为了查找便捷，一般都使用Hash表来实现这个会话表，以提高转发的效率</li><li>Linux内核大量采用Hash Table</li></ul><pre class="line-numbers language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Chinese"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Math"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"English"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"History"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Politic"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JTAG救活USRP X310的前前后后</title>
      <link href="/2019/05/23/use-jtag-to-burn-temporary-images-to-usrp-x310/"/>
      <url>/2019/05/23/use-jtag-to-burn-temporary-images-to-usrp-x310/</url>
      
        <content type="html"><![CDATA[<p>在配完紫丁香卫星地面站的环境后，由于毕设需要，需要安装与GNU Radio版本对应的UHD驱动，当时手残，在给USRP烧录img镜像至60%左右时，按了Ctrl+C终止了这一过程，直接导致USRP和PC无法通过千兆以太网连接，当时心态有点崩，因为这个设备值5万多呢，心想一下被我搞坏了这可咋整，把我卖了也不值这个价啊，想了很多办法，遇到很多坑，最后通过USRP X310预留的JTAG口救活了它。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为方便解决一大堆包依赖的问题，一开始使用GNU Radio的包管理系统Pybombs（Python Build Overlay Managed Bundle System）安装了GNU Radio：</p><p><a href="http://www.hackrf.net/2016/06/pybombs-mirror-tuna/" target="_blank" rel="noopener">http://www.hackrf.net/2016/06/pybombs-mirror-tuna/</a></p><p>也可参考github上的README：<a href="https://github.com/gnuradio/gnuradio" target="_blank" rel="noopener">https://github.com/gnuradio/gnuradio</a> （Pybombs or Manual Install）</p><p>网速好的话安装过程大约几个小时就搞定，由于Pybombs的recipes（这里我们称它为菜谱，含义如同名字一样，是GNU Radio主要维护的开源包，托管在github下面：<a href="https://github.com/gnuradio/gr-recipes" target="_blank" rel="noopener">gr-recipes</a>），而毕设使用的开源项目<a href="https://gitlab.com/librespacefoundation/gr-leo?nav_source=navbar" target="_blank" rel="noopener">gr-leo</a> 不是它主要维护的，因此当手动编译 <a href="https://gitlab.com/librespacefoundation/gr-leo?nav_source=navbar" target="_blank" rel="noopener">gr-leo</a> 完成后，会使得 <a href="https://github.com/bg2bhc/gr-lilacsat" target="_blank" rel="noopener">gr-lilacsat</a>、<a href="https://github.com/osmocom/gr-osmosdr" target="_blank" rel="noopener">gr-osmosdr</a>等发生冲突，初步分析是由于手动编译后自己更改了GNU Radio的默认blocks搜索路径，导致 <a href="https://gitlab.com/librespacefoundation/gr-leo?nav_source=navbar" target="_blank" rel="noopener">gr-leo</a> 、<a href="https://gitlab.com/librespacefoundation/satnogs/gr-satnogs" target="_blank" rel="noopener">gr-satnogs</a> 等给出的examples中用到的信号处理子模块索引不到，出现<code>missing blocks</code>的错误，虽然后续可以通过更改GNU Radio打开初始化索引block的路径，更改方法如下：</p><p>更改gnuradio-prefix下的<code>gnuradio-prefix/etc/gnuradio/conf.d/grc.conf</code>,在<code>local_blocks_path=</code>（本地信号子模块索引路径）加上<code>/usr/local/share/gnuradio/grc/blocks</code>,用pybombs安装gnuradio所有关于gunradio的东西都在你新建的gnuradio-prefix中，当然也不一定是gnuradio-prefix，也可能是其他你新建的文件夹</p><p><img src="1.jpg" alt></p><p>但这并不是一劳永逸的办法，最好的办法是手动编译安装GNU Radio，虽然麻烦了点，但是不会出这样那样的问题，可能是我对GNU Radio编译安装的框架还不太熟悉，所以当我手动编译ge-leo时，默认编译路径是在<code>/usr/...</code>下的(我的是<code>usr/local/share/</code>)，</p><p><img src="2.jpg" alt></p><p>所以只能采取笨一点的办法，所有关于gnuradio的开源包均手动编译。</p><p><strong>更新：可以在<code>cmake ../</code>的时候预先设置编译路径，这是个好办法，但我还没尝试，用<code>cmake -DCMAKE_INSTALL_PREFIX=/gnuradio-prefix/share ..</code>命令，之前是在编译完后设置的，所以出bug了</strong></p><p>但是每次编译都得手动设置编译路径，比较麻烦，所以干脆直接从安装gnuradio到uhd到其他gr开源包，全部手动编译比较省事</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>使用的软件无线电平台是usrp x310，采用万兆转千兆适配器通过网线与主机PC相连，若下载HG镜像，使用万兆转千兆适配器通过Port0与主机相连，usrp x310 的默认IP地址为：<code>192.168.10.2</code>，如下图所示</p><p><img src="3.jpg" alt></p><p><img src="4.png" alt></p><p>在执行grc文件时出现<code>RuntimeError: AssertionError: Failed to find a valid XML path for RFNoC bloc</code>的错误</p><p><img src="5.jpg" alt></p><p>然后重新设置了下block路径，点击执行之后报错：FPGA image和uhd驱动不兼容，建议我重新烧录镜像，重新刷镜像时由于手误按了下强行终止（Ctrl+C），导致镜像烧录到一半就停止了，然后终端给我反馈信息说你这样的操作会使usrp处于一种不稳定的状态，然后usrp和PC端就无法进行数据交互了，无法ping通，一开始找了很多办法，换网线，打开USRP外壳想通过reset复位按键让usrp恢复出厂设置，然而打开之后发现里头只有SW1和SW3两个按键，不管三七二十一按着这俩键重启usrp，但是一点效果都没有，依旧ping不通，当时咨询了老师，说按着里头某个按键重启设备可以让他进入安全模式，后来才知道这是usrp N210的操作，它里头靠近射频子板的旁边确实有一个蓝色的复位按钮S2，但是X310直接舍弃了这种复位操作，取而代之的是加入了JTAG口，从而可在FPGA环境下对usrp进行暂时性的刷入固件，掉电后固件会丢失，因为USRP FPGA镜像中包含了网口驱动以及其他驱动，所以这也就是当我终止<code>usrp_x3xx_fpga_burner --addr=192.168.10.2</code>写入镜像命令时为何PC无法和usrp进行通信的原因，由于缺少网口驱动，PC无法通过网线和usrp进行数据交互。</p><p>后来还联系了NI上海的技术服务，依旧没有解决，想着五万多的设备就这么被我玩坏了，每天脑子里老是想着怎么去解决这个问题，一直觉得强行终止烧入镜像命令这个误操作根本就不会使硬件烧掉，中期答辩的时候也向熟悉USRP设备的老师确认了肯定没坏，只是变成砖了，需要想另外的办法恢复。后面和大佬讨论试试JTAG，因为既然留给了用户必定是有用的，在google中搜索各种搜索，不过貌似直接搜索usrp x310 jtag就有了解决办法的博客，虽然中间还是遇到了很多问题，但是解决的那一刻还是蛮开心的。</p><h3 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h3><p>Ettus官方给出的USRP Hardware Driver and USRP Manual文档链接如下：</p><p><a href="http://files.ettus.com/manual/page_usrp_x3x0.html#x3x0_load_fpga_imgs_jtag" target="_blank" rel="noopener">http://files.ettus.com/manual/page_usrp_x3x0.html#x3x0_load_fpga_imgs_jtag</a></p><p><strong>如下图所示，里面提到如果不小心下错镜像或者刷入bad image【我提到的不完整镜像（刷到一半终止）也可称之为bad image】，则会让usrp变成砖（”bricking”），但幸运的是，usrp x310提供了USB-JTAG接口使FPGA镜像能暂时性烧录进usrp中，从而加载网口和pcie驱动，使得上电状态时网口和pcie接口可以和主机PC进行通信，但是如果一旦掉电，镜像便随之丢失，因为通过jtag无法将镜像固化到F板载FPGA片上Flash上，所以可以先通过jtag Programmer将镜像临时导入usrp，再通过usrp或者peie将镜像固化到片上flash上。</strong></p><p><img src="6.jpg" alt></p><p>操作方法如下：</p><h4 id="Linux下搭建FPGA调试环境"><a href="#Linux下搭建FPGA调试环境" class="headerlink" title="Linux下搭建FPGA调试环境"></a>Linux下搭建FPGA调试环境</h4><p><strong>我安装是Ubuntu18.04 LTS版本，在Vivado2018.3环境下进行JTAG烧录镜像</strong></p><p>参考网上博客他们的系统是Ubnutu16.04，因此对应vivado版本不能过高，他们安装的是2017.4版本</p><p><img src="7.jpg" alt></p><p>我尝试过Vivado2017.4版本，到安装界面时提示我vivado2017.4支持到Ubuntu16.04，因此我就直接退出重新下载2018.3版本了，2018.2版本没有试过，应该也是可以的，毕竟Ubuntu18.04 LTS发布时间也是在2018年</p><p>安装过程参考教程：</p><p><a href="https://blog.csdn.net/wmyan/article/details/78926324" target="_blank" rel="noopener">https://blog.csdn.net/wmyan/article/details/78926324</a></p><ol><li><p>在xilinx官网下载vivado2018.3的linux版本： </p><p><img src="8.jpg" alt></p><p>这里我下载了不用license的WebPack免费版，当然也可以下载其他版本，不过需要license，根据需要安装就行（下载bin文件就行，执行之后会类似于visual studio 2017安装一样，在线下载安装包，这个过程需要挺久，尽量保持网络环境良好），关于这几种版本的区别，参考网址：</p><p><a href="https://china.xilinx.com/products/design-tools/vivado/vivado-webpack.html" target="_blank" rel="noopener">https://china.xilinx.com/products/design-tools/vivado/vivado-webpack.html</a></p></li><li><p>在你下载的bin文件目录下（linux下一般默认下载在<code>~/Download/</code>文件夹下）打开终端，执行命令：</p><p><code>sudo ./Xilinx_Vivado_SDK_Web_2018.3_1207_2324_Lin64.bin</code></p><p>自动弹出安装界面，根据需要点击next行，注意一点就是：xilinx套路比较深，在它的官网下载安装包需要注册一个xilinx账号且填写个人信息和用途才能下载，这里的installer一样，需要填写xilinx账号</p></li><li><p>安装完成后，添加源：</p><p><code>source /tools/Xilinx/Vivado/2018.3/settings64.sh</code></p><p>就可以直接在终端中输入<code>vivado</code>启动了</p><p>注意：vivado2018.3在linux安装目录和2017.4的默认路径更改了，2017.4的默认安装路径是：</p><p><code>/opt/Xilinx/Vivado/2017.4/...</code></p><p>2018.3的默认路径是：<code>/tools/Xilinx/Vivado/2018.3/...</code></p><p>这里也可直接<code>touch vivado.sh</code>,在里面输入：</p><p><code>source /tools/Xilinx/Vivado/2018.3/settings64.sh</code></p><p><code>vivado</code></p><p>保存OK，在命令行<code>cd</code>进入<code>vivado.sh</code>文件目录，执行<code>vivado.sh</code>便可打开vivado</p><p>其他的我就不多说了，基本都是Linux常规操作，不会的google、baidu都行</p></li></ol><h4 id="Use-JTAG-to-load-FPGA-images"><a href="#Use-JTAG-to-load-FPGA-images" class="headerlink" title="Use JTAG to load FPGA images"></a>Use JTAG to load FPGA images</h4><p>装好vivado环境后，就可以使用JTAG将镜像导入USRP中了</p><p>JTAG线使用的USB 2.0 JTAG方口线，平常打印机与电脑的连接线以及STM32 JTAG调试器使用的数据线就是种，没有的话淘宝搜索USB方口线买一根</p><p><strong>按照官网教程，在终端执行如图所示三条命令：</strong></p><p><code>cd uhd/fpga-src/ursp3/top/x300</code></p><p><code>source ./setup.sh</code></p><p><code>viv_jtag_program /path/to/bitfile.bit</code></p><p>但是写的不够直观，中途还是遇到很多bug，具体操作见下：</p><p><img src="9.jpg" alt></p><p>不过在执行之前，由于其提到的fpga-src文件夹下有usrp1、usrp2、usrp3等子目录，我查看了一下用pybombs安装gnuradio的目录：<code>gunradio-prefix/src/uhd/fpga-src/</code>,文件夹是空的，可能是用pybombs安装gunradio以及手动编译gr-…等依赖包出了问题，所以手动下载fpga-src，github网址：</p><p><a href="https://github.com/EttusResearch/fpga/tree/4bc2c6fc62481452033463ce354ca1ab0343342f" target="_blank" rel="noopener">https://github.com/EttusResearch/fpga/tree/4bc2c6fc62481452033463ce354ca1ab0343342f</a></p><p>在<code>gunradio-prefix/src/uhd/fpga-src/</code>打开终端(其他目录同理)，命令行输入：</p><p><code>git clone https://github.com/EttusResearch/fpga.git</code></p><p>下载克隆fpga镜像，并将镜像拷贝到<code>.../fpga-src/usrp3/top/x300</code>目录下，然后cd打开该目录，执行添加源命令：</p><p><code>source ./setupenv.sh --vivado-path=/tools/Xilinx/Vivado</code></p><p><img src="10.jpg" alt></p><p>当终端反馈信息为：Environment successful initialized，即：vivado环境搭建成功，就可以开始下一步的操作了</p><p>注意：由于vivado2017.4版本安装路径默认是：<code>/opt/Xilinx/Vivado</code></p><p>所以添加源的时候记得把vivado路径加入：<code>--vivado_path=/tools/Xilinx/Vivado</code>，不然会报错，如下图所示</p><p><img src="11.jpg" alt></p><p>最后一步执行命令：</p><p><code>viv_jtag_program /usr/share/uhd/images/usrp_x310_fpga_HG.bit</code></p><p>关于HG、HGS、XG、HA不同镜像的区别，参考Ettus给出的标准硬件文档：</p><p><a href="http://files.ettus.com/manual/page_usrp_x3x0.html#x3x0_load_fpga_imgs_jtag" target="_blank" rel="noopener">http://files.ettus.com/manual/page_usrp_x3x0.html#x3x0_load_fpga_imgs_jtag</a></p><p>这里也可选择<code>usrp_x300_fpga_HG.bit</code>,因为我使用的是usrpx310，属于x300系列子产品</p><p>然而，事事不遂人意，执行第三条命令出现如下图错误：</p><p><code>ERROR: [Labtoolstcl 44-199] No matching targets found on connected servers: localhost</code></p><p><img src="12.jpg" alt></p><p><img src="13.jpg" alt></p><p>在这个地方卡了快将近一天，一直提示说找不到Xilinx的hw_server，也就是usrp板载FPGA芯片无法通过JTAG和PC进行数据交互，直接<code>ping localhost:3121</code>也无法ping通，试了很多办法，开始以为FPGA芯片坏了，后来才发现是<strong>缺少jtag驱动</strong>！！！</p><p>vivado默认安装后是没有装jtag驱动的，对于ubuntu18.04下的vivado2018.3是这样，我没试过其他版本，也可能是安装过程中需要勾选这一项，但是当时安装vivado的时候并没有看到这项，在win10系统下默认安装了硬件驱动，不然也没法连接硬件</p><p>关于如何手动安装jtag驱动，我参考了这篇帖子：</p><p> <a href="https://blog.csdn.net/sinat_33384994/article/details/70232212" target="_blank" rel="noopener">https://blog.csdn.net/sinat_33384994/article/details/70232212</a></p><p>xilinx官方也给出了解决方案：</p><p><a href="https://www.xilinx.com/support/answers/54381.html" target="_blank" rel="noopener">https://www.xilinx.com/support/answers/54381.html</a></p><p>我试了他给出的常规方法：Full sudo -s access</p><p>但具体的目录和相应的命令需要根据实际vivado安装目录更改，因为官方给出的方案应该是较老版本的linux和vivado的，它的vivado默认安装路径为<code>/opt/Xilinx/Vivado/...</code></p><p><img src="14.jpg" alt></p><p>其他的方法也可以试一试，应该问题不大</p><h6 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h6><ul><li><input disabled type="checkbox"> <p>先进入root账户，否则没法继续下一步</p><p><code>sudo -s</code></p><p><img src="15.jpg" alt></p></li><li><input disabled type="checkbox"> <p>进入vivado安装目录下的bin，但是最新版的vivado的bin目录下没有教程中第三步提到的<code>install_drivers</code>子目录，这个文件夹默认在<code>/tools/Xilinx/Vivado/2018.3/data/xicom/cable_drivers/lin64/install_script/install_drivers</code>下面，如果不是，直接在在安装目录下搜索下这个文件</p></li><li><input disabled type="checkbox"> <p>将<code>install_script/install_drivers</code>目录复制到<code>/tools/</code>目录下</p><p><code>cp -i -r install_script /tools/</code></p></li><li><input disabled type="checkbox"> <p>切换到<code>/tools/install_script/install_drivers</code>目录，执行：</p><p><code>./install_drivers</code></p><p>最后一步更改linux外部挂载设备（device）的读写权限，这个看情况执行，我的没有执行这一步也可以将驱动安装成功</p><p>OK，反馈信息<code>Dirver Installation successful</code>，JTAG驱动安装完成</p></li></ul><p><img src="16.jpg" alt></p><p>继续执行：</p><p><code>viv_jtag_program /usr/share/uhd/images/usrp_x310_fpga_HG.bit</code></p><p><img src="17.jpg" alt></p><p>然后反馈<code>Programming DONE</code>，大功告成！</p><p>如果之前没有下载安装镜像文件，先<code>sudo uhd_image_downloader</code>一下，再执行上述命令</p><p>然后，<code>uhd_find_devices</code>，发现能找到设备，</p><p><img src="18.png" alt></p><p>并且<code>ping 192168.10.2</code>也能ping通，这也说明镜像中确实附带网口驱动，再切换到<code>/usr/lib/uhd/utils/</code>执行<code>usrp_x3xx_fpga_burner --addr=192.168.10.2</code>将镜像固化到flash中(<code>utils/</code>目录根据uhd安装目录实际调整)，重启usrp设备，Game Over！</p><p>另外：如果驱动安装不成功的话，检查一下jtag线</p><p>​            命令行<code>lsusb</code>检查下usb-jtag线是否连上，能否传输数据</p><p>参考博客：<a href="https://blog.csdn.net/qq_34998254/article/details/83302584" target="_blank" rel="noopener">https://blog.csdn.net/qq_34998254/article/details/83302584</a></p><p>Ettus官网UHD Manual链接：</p><ul><li><input disabled type="checkbox"> <p>主文档： <a href="http://files.ettus.com/manual/index.html" target="_blank" rel="noopener">http://files.ettus.com/manual/index.html</a></p></li><li><input disabled type="checkbox"> <p>子文档： <a href="http://files.ettus.com/manual/page_usrp_x3x0.html#x3x0_flash" target="_blank" rel="noopener">USRP X3x0 Series </a></p></li></ul><p>谢谢各位大哥的博客，让我有了救活老师五万多设备的希望，这里建议大家，对于linux系统和usrp的使用，一定要多尝试，特别是像我这种不熟悉linux命令操作的同志，一定要多试，网上给出的那些教程，高低参差不齐，需要择木而栖</p><ul><li><input disabled type="checkbox"> 搜索：google为主，baidu为辅</li><li><input disabled type="checkbox"> 常逛github、gitlab等开源仓库</li><li><input disabled type="checkbox"> 学会英文关键词检索：google+github</li><li><input disabled type="checkbox"> 对于gnuradio这种基于GNU开源协议的软件，多参考Ettus和gnuradio以官网及github上给出的英文文档，会受益匪浅</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件无线电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gnuradio </tag>
            
            <tag> USRP X310 </tag>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻型卫星地面站</title>
      <link href="/2018/12/15/light-satellite-ground-station/"/>
      <url>/2018/12/15/light-satellite-ground-station/</url>
      
        <content type="html"><![CDATA[<p>小型卫星地面站系统由智讯创新团队，HITWH业余无线电俱乐部负责研发。初步计划完成地面站系统初样，实现稳定工作，并完成星地链路通信，通联紫丁香一号卫星Lilacsat-1（LO-90），接收卫星下传图片。</p><p><img src="1.jpg" alt="LilacSat-1"></p><h2 id="紫丁香1号卫星简介"><a href="#紫丁香1号卫星简介" class="headerlink" title="紫丁香1号卫星简介"></a>紫丁香1号卫星简介</h2><p>紫丁香一号是哈工大学生团队研制的一颗2U立方体卫星，以大气低热层科学探测为主要任务，重仅2 kg，参与欧洲QB50计划，于2017.4搭载货运飞船前往国际空间站，再由日本实验舱机械臂弹射入轨。</p><p>紫丁香一号的主要载荷是伦敦大学学院(UCL)研制的离子和中性粒子质谱仪(INMS)，可测量带电离子和中性原子的质量与分布情况。全球高校研制的48颗卫星协同工作，对人类尚未深入涉足的大气低热层开展实地研究。除科学载荷外，紫丁香一号还搭载了FM/Codec2-BPSK转发器和彩色CCD相机。FM/Codec2-BPSK转发器是一种新体制的业余无线电卫星转发器，上行使用传统的FM模拟语音，在星上进行数字化，由开源声码器Codec2进行数据压缩，并与遥测数据融合后下传，可有效提高功率与频谱利用效率以及遥测数据流量。彩色CCD相机设计有公开的拍摄与下传接口，可由爱好者发送指令进行操作。</p><p>紫丁香1号的U/VHF业余无线电载荷信息如下：</p><table><thead><tr><th align="left">UPLINK</th><th align="left">DOWNLINK</th></tr></thead><tbody><tr><td align="left">上行频率：145.985MHz</td><td align="left">下行频率：436.51MHz</td></tr><tr><td align="left">Antenna：1/4波长单极天线</td><td align="left">Antenna：1/4波长单极天线</td></tr><tr><td align="left">极化方式：线极化</td><td align="left">极化方式：线极化</td></tr><tr><td align="left">Protocol：</td><td align="left">Protocol/Voice Coding：</td></tr><tr><td align="left">转发器：Analog Voice</td><td align="left">遥测：CSP</td></tr><tr><td align="left">相机接口：AX.25 UI</td><td align="left">转发器：Codec2</td></tr><tr><td align="left">调制方式</td><td align="left">信道编码：（7,1/2卷积码）</td></tr><tr><td align="left">FM转发器：FM，67Hz，亚音</td><td align="left">调制方式：9600bps RRC-BPSK NRZ-M</td></tr><tr><td align="left">相机接口：1000bps AFSK</td><td align="left">下行功率：23/27dBm</td></tr></tbody></table><p>卫星地面站通过天线追踪系统<a href="https://github.com/OpenATS/OpenATS" target="_blank" rel="noopener">OpenATS</a>控制自制的数字旋转器实时对准Lilacsat-1，当卫星过境时控制电台发射image指令（0x00，0x55，0xaa）控制紫丁香1号拍照并下传图像，通过紫丁香团队的gnuradio解调程序进行图像解调，恢复原始图像信息。</p><h2 id="方案目标"><a href="#方案目标" class="headerlink" title="方案目标"></a>方案目标</h2><ul><li>完成地面站初样，实现星地通信（通联LilacSat-1以及LilacSat-2等），收到紫丁香1号、2号信标，并成功解调1号下传图像信息。</li></ul><h2 id="地面站组成"><a href="#地面站组成" class="headerlink" title="地面站组成"></a>地面站组成</h2><p>小型微型地面站主要由三部分组成：</p><ul><li>发射机：发送CMOS相机载荷上行控制指令</li><li>接收机：信标和下行图片数据解调解码</li><li>天线旋转器系统：实时追踪卫星</li></ul><p>地面站系统整体结构框图如下：</p><p><img src="2.png" alt="地面站系统框图"></p><h2 id="系统方案设计"><a href="#系统方案设计" class="headerlink" title="系统方案设计"></a>系统方案设计</h2><h3 id="发射机方案"><a href="#发射机方案" class="headerlink" title="发射机方案"></a>发射机方案</h3><ul><li>发射机采用Yaesu FT-8900R无线电台，计算机通过电台控制PCB转接板控制无线电台，发射指令控制卫星相机载荷</li><li>发射天线采用V段10单元八木，增益11.6dBi，驻波比小于1.3</li><li>上行控制指令采用AFSK调制方式，指令协议为AX.25，将数据帧调制成音频，通过FM调制发射<ul><li>0x00：拍摄一幅图像并下传</li><li>0x55：拍摄一幅图像并存储</li><li>0xaa：读取已存储的图像并下传</li></ul></li></ul><p>制作测试好的PCB电台转接板：</p><p><img src="3.png" alt="PCB转接板实物图"></p><p>发射控制客户端软件界面（由BI4KLK编写），主要实现电脑点击Telecommd(发射指令)通过PCB转接板转成电台的PTT发射FM射频信号。</p><p><img src="4.png" alt="发射控制界面"></p><p>###接收机方案</p><ul><li>接收机采用430-440MHz UHF 15单元八木天线，增益14dBi</li><li>前端加入LNA，433MHz，增益15dBi，噪声系数0.5dB(BD4OS高老师提供LNA)</li><li>USRP X310</li><li>通过GNU Radio进行解调解码（BG2BHC提供解调源码）</li></ul><p>LNA：</p><p><img src="5.png" alt="LNA实物图"></p><p>软件无线电平台USRP X310</p><p><img src="6.png" alt="USRP X310"></p><h3 id="接收机解码程序：frontend-rx-uhd"><a href="#接收机解码程序：frontend-rx-uhd" class="headerlink" title="接收机解码程序：frontend_rx_uhd"></a>接收机解码程序：frontend_rx_uhd</h3><p><img src="7.png" alt="接收机解码GRC流图1"></p><h3 id="接收机解码程序：demod"><a href="#接收机解码程序：demod" class="headerlink" title="接收机解码程序：demod"></a>接收机解码程序：demod</h3><p><img src="8.png" alt="接收机解码GRC流图2"></p><h3 id="天线旋转器方案"><a href="#天线旋转器方案" class="headerlink" title="天线旋转器方案"></a>天线旋转器方案</h3><ul><li>天线旋转器采用步进电机（2相4线2.3N.m）配合蜗杆减速机（RV030,1:30），AZ（方位）与EL（俯仰）两个自由度旋转</li><li>配合步进电机驱动器，Arduino作为下位机控制电机实现追踪，下位机系统参照OpenATS（开源），EasyComm协议</li><li>上位机使用卫星追踪软件实现高精度自动追踪卫星：<ul><li>Windows平台：Wxtrack</li><li>Linux平台：Gpredict+HamLlib</li></ul></li></ul><h3 id="地面站系统完成实物图"><a href="#地面站系统完成实物图" class="headerlink" title="地面站系统完成实物图"></a>地面站系统完成实物图</h3><p><img src="9.jpg" alt></p><p><img src="10.jpg" alt></p><p><img src="11.jpg" alt></p><h3 id="机械结构改进"><a href="#机械结构改进" class="headerlink" title="机械结构改进"></a>机械结构改进</h3><p>旋转器在追踪卫星时，为了减轻电机转动时的扭矩，我们将旋转器控制系统移到了旋转器下方，通过U型卡与防水盒进行集成封装固定，后期需要将整个控制系统集成制成PCB控制板，减少延长线带来的干扰以及其他电磁干扰。</p><p><img src="12.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/006lWeFfly1g8e0xcnu8yj30m20cenh9.jpg" alt></p><p>（活捉一只大佬哈哈哈…，地面站系统的总体负责人BI4KLK）</p><p><img src="13.jpg" alt></p><p>地面站系统演示视频：</p><p>链接: <a href="https://pan.baidu.com/s/1aeHmvmL9rm1vFldmGC1t6Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1aeHmvmL9rm1vFldmGC1t6Q</a> 提取码: m62v</p><h3 id="测试情况"><a href="#测试情况" class="headerlink" title="测试情况"></a>测试情况</h3><p>20190315：成功收到LilacSat-1信标</p><p><img src="14.png" alt></p><p>20190418：成功收到LilacSat-2信标并监听到其他Ham通联情况</p><p><img src="15.png" alt></p><p>具体可见视频：链接: <a href="https://pan.baidu.com/s/1kJf_Da0FVDi0Gzvdgd3ZpA" target="_blank" rel="noopener">https://pan.baidu.com/s/1kJf_Da0FVDi0Gzvdgd3ZpA</a> ，提取码: cgme </p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li>OpenATS（Open Antenna Tracking System）：郝经利（BI1GMM）</li><li>哈工大紫丁香团队，龙江卫星总师：韦明川（BG2BHC）</li><li>高国强（BD4OS）</li><li>方案参考：BG6LQV、BG6WRI</li><li>智讯创新工作室团队、各位老师的支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> Amateur Radio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 螺旋天线制作 </tag>
            
            <tag> 机械结构 </tag>
            
            <tag> LNA </tag>
            
            <tag> OpenATS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
